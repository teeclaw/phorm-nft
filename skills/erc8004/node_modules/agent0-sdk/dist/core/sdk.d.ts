/**
 * Main SDK class for Agent0
 */
import type { AgentSummary, Feedback, FeedbackFileInput, SearchOptions, FeedbackSearchFilters, FeedbackSearchOptions, SearchFilters } from '../models/interfaces.js';
import type { AgentId, ChainId, Address, URI } from '../models/types.js';
import type { ChainClient, EIP1193Provider as Eip1193Provider } from './chain-client.js';
import { IPFSClient } from './ipfs-client.js';
import { SubgraphClient } from './subgraph-client.js';
import { Agent } from './agent.js';
import type { TransactionHandle } from './transaction-handle.js';
export interface SDKConfig {
    chainId: ChainId;
    rpcUrl: string;
    /**
     * Backwards-compatible alias for `privateKey` (accepts a hex private key string).
     */
    signer?: string;
    /**
     * Server-side signing (hex private key string).
     */
    privateKey?: string;
    /**
     * Browser-side signing (EIP-1193 provider, typically selected via ERC-6963).
     */
    walletProvider?: Eip1193Provider;
    registryOverrides?: Record<ChainId, Record<string, Address>>;
    ipfs?: 'node' | 'filecoinPin' | 'pinata';
    ipfsNodeUrl?: string;
    filecoinPrivateKey?: string;
    pinataJwt?: string;
    subgraphUrl?: string;
    subgraphOverrides?: Record<ChainId, string>;
}
/**
 * Main SDK class for Agent0
 */
export declare class SDK {
    private readonly _chainClient;
    private _ipfsClient?;
    private _subgraphClient?;
    private readonly _feedbackManager;
    private readonly _indexer;
    private readonly _registries;
    private readonly _chainId;
    private readonly _subgraphUrls;
    private readonly _hasSignerConfig;
    constructor(config: SDKConfig);
    /**
     * Initialize IPFS client based on configuration
     */
    private _initializeIpfsClient;
    /**
     * Get current chain ID
     */
    chainId(): Promise<ChainId>;
    /**
     * Get resolved registry addresses for current chain
     */
    registries(): Record<string, Address>;
    /**
     * Get subgraph client for a specific chain
     */
    getSubgraphClient(chainId?: ChainId): SubgraphClient | undefined;
    identityRegistryAddress(): Address;
    reputationRegistryAddress(): Address;
    validationRegistryAddress(): Address;
    /**
     * Check if SDK is in read-only mode (no signer)
     */
    get isReadOnly(): boolean;
    /**
     * Create a new agent (off-chain object in memory)
     */
    createAgent(name: string, description: string, image?: URI): Agent;
    /**
     * Load an existing agent (hydrates from registration file if registered)
     */
    loadAgent(agentId: AgentId): Promise<Agent>;
    /**
     * Get agent summary from subgraph (read-only)
     * Supports both default chain and explicit chain specification via chainId:tokenId format
     */
    getAgent(agentId: AgentId): Promise<AgentSummary | null>;
    /**
     * Search agents with filters
     * Supports multi-chain search when chains parameter is provided
     */
    searchAgents(filters?: SearchFilters, options?: SearchOptions): Promise<AgentSummary[]>;
    /**
     * Transfer agent ownership
     */
    transferAgent(agentId: AgentId, newOwner: Address): Promise<TransactionHandle<{
        txHash: string;
        from: Address;
        to: Address;
        agentId: AgentId;
    }>>;
    /**
     * Check if address is agent owner
     */
    isAgentOwner(agentId: AgentId, address: Address): Promise<boolean>;
    /**
     * Get agent owner
     */
    getAgentOwner(agentId: AgentId): Promise<Address>;
    /**
     * Prepare an off-chain feedback file.
     *
     * This does NOT include on-chain fields like score/tag1/tag2/endpoint.
     */
    prepareFeedbackFile(input: FeedbackFileInput, extra?: Record<string, unknown>): FeedbackFileInput;
    /**
     * Give feedback
     */
    giveFeedback(agentId: AgentId, value: number | string, tag1?: string, tag2?: string, endpoint?: string, feedbackFile?: FeedbackFileInput): Promise<TransactionHandle<Feedback>>;
    /**
     * Read feedback
     */
    getFeedback(agentId: AgentId, clientAddress: Address, feedbackIndex: number): Promise<Feedback>;
    /**
     * Search feedback
     */
    searchFeedback(filters: FeedbackSearchFilters, options?: FeedbackSearchOptions): Promise<Feedback[]>;
    /**
     * Append response to feedback
     */
    appendResponse(agentId: AgentId, clientAddress: Address, feedbackIndex: number, response: {
        uri: URI;
        hash: string;
    }): Promise<TransactionHandle<Feedback>>;
    /**
     * Revoke feedback
     */
    revokeFeedback(agentId: AgentId, feedbackIndex: number): Promise<TransactionHandle<Feedback>>;
    /**
     * Get reputation summary
     */
    getReputationSummary(agentId: AgentId, tag1?: string, tag2?: string): Promise<{
        count: number;
        averageValue: number;
    }>;
    /**
     * Create an empty registration file structure
     */
    private _createEmptyRegistrationFile;
    /**
     * Private helper methods
     */
    private _loadRegistrationFile;
    /**
     * Transform raw registration file (from IPFS/HTTP) to RegistrationFile format
     * Accepts raw JSON data which may have legacy format or new format
     */
    private _transformRegistrationFile;
    /**
     * Transform endpoints from old format { name, endpoint, version } to new format { type, value, meta }
     */
    private _transformEndpoints;
    /**
     * Transform a single endpoint from legacy format
     */
    private _transformEndpointLegacy;
    /**
     * Extract wallet address and chain ID from raw data
     */
    private _extractWalletInfo;
    get chainClient(): ChainClient;
    get ipfsClient(): IPFSClient | undefined;
    get subgraphClient(): SubgraphClient | undefined;
}
//# sourceMappingURL=sdk.d.ts.map