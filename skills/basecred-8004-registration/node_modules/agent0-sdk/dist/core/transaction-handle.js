export class TransactionHandle {
    constructor(hash, chainClient, computeResult) {
        this.chainClient = chainClient;
        this.computeResult = computeResult;
        this.memo = new Map();
        this.hash = hash;
    }
    async waitMined(opts = {}) {
        const key = JSON.stringify({
            timeoutMs: opts.timeoutMs ?? null,
            confirmations: opts.confirmations ?? null,
            throwOnRevert: opts.throwOnRevert ?? null,
        });
        const existing = this.memo.get(key);
        if (existing)
            return await existing;
        const promise = (async () => {
            const receipt = await this.chainClient.waitForTransaction({
                hash: this.hash,
                timeoutMs: opts.timeoutMs,
                confirmations: opts.confirmations,
            });
            const throwOnRevert = opts.throwOnRevert ?? true;
            if (throwOnRevert && receipt.status === 'reverted') {
                throw new Error(`Transaction reverted: ${this.hash}`);
            }
            const result = await this.computeResult(receipt);
            return { receipt, result };
        })();
        this.memo.set(key, promise);
        return await promise;
    }
    /**
     * Alias of waitMined (naming convenience).
     */
    async waitConfirmed(opts = {}) {
        return await this.waitMined(opts);
    }
}
//# sourceMappingURL=transaction-handle.js.map