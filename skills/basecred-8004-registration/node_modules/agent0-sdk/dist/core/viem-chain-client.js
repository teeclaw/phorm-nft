import { createPublicClient, createWalletClient, custom, defineChain, http, keccak256, toBytes, isAddress as viemIsAddress, getAddress as viemGetAddress, encodeFunctionData, getAbiItem, } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { normalizeEcdsaSignature } from '../utils/signatures.js';
function normalizeHexKey(key) {
    const k = key.trim();
    const with0x = k.startsWith('0x') ? k : `0x${k}`;
    return with0x;
}
function toViemAddress(addr) {
    return addr;
}
function toSdkAddress(addr) {
    return addr;
}
function toViemTxOptions(options) {
    if (!options)
        return {};
    const out = {};
    if (options.gasLimit !== undefined)
        out.gas = options.gasLimit;
    if (options.gasPrice !== undefined)
        out.gasPrice = options.gasPrice;
    if (options.maxFeePerGas !== undefined)
        out.maxFeePerGas = options.maxFeePerGas;
    if (options.maxPriorityFeePerGas !== undefined)
        out.maxPriorityFeePerGas = options.maxPriorityFeePerGas;
    return out;
}
export class ViemChainClient {
    constructor(config) {
        this.chainId = config.chainId;
        this.rpcUrl = config.rpcUrl;
        // viem requires a `chain` to be set for some wallet-client actions (e.g. writeContract)
        // when using an EIP-1193 wallet provider transport. We construct a minimal chain object
        // from chainId + rpcUrl so consumers don't need to provide viem chain definitions.
        const viemChain = defineChain({
            id: this.chainId,
            name: `chain-${this.chainId}`,
            nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
            rpcUrls: { default: { http: [this.rpcUrl] } },
        });
        this.publicClient = createPublicClient({
            chain: viemChain,
            transport: http(this.rpcUrl),
        });
        if (config.privateKey) {
            this.account = privateKeyToAccount(normalizeHexKey(config.privateKey));
            this.walletClient = createWalletClient({
                chain: viemChain,
                account: this.account,
                transport: http(this.rpcUrl),
            });
        }
        else if (config.walletProvider) {
            // When using a browser wallet, transactions may be submitted via the wallet's RPC backend.
            // Some public RPCs can lag or be out of sync, which can cause receipt polling timeouts.
            // We keep `publicClient` on rpcUrl for normal reads, but use this receiptClient as a fallback
            // for `waitForTransaction` when the rpcUrl path times out.
            this.receiptClient = createPublicClient({
                chain: viemChain,
                transport: custom(config.walletProvider),
            });
            this.walletClient = createWalletClient({
                chain: viemChain,
                transport: custom(config.walletProvider),
            });
        }
    }
    async getAddress() {
        // Private key path
        if (this.account) {
            return toSdkAddress(this.account.address);
        }
        // Wallet provider path (non-interactive): eth_accounts
        if (!this.walletClient)
            return undefined;
        try {
            const addrs = await this.walletClient.getAddresses?.();
            if (Array.isArray(addrs) && typeof addrs[0] === 'string') {
                return toSdkAddress(addrs[0]);
            }
        }
        catch {
            // fall through
        }
        try {
            const prov = this.walletClient.transport?.value;
            const accounts = prov ? await prov.request({ method: 'eth_accounts' }) : undefined;
            if (Array.isArray(accounts) && typeof accounts[0] === 'string') {
                return toSdkAddress(accounts[0]);
            }
        }
        catch {
            // ignore
        }
        return undefined;
    }
    async ensureAddress() {
        const existing = await this.getAddress();
        if (existing)
            return existing;
        // Private key path has no interactive prompt; if missing, it's a config error.
        if (this.account) {
            throw new Error('No account available (privateKey configured but address could not be resolved)');
        }
        if (!this.walletClient) {
            throw new Error('No signer available. Configure walletProvider (browser) or privateKey (server).');
        }
        const prov = this.walletClient.transport?.value;
        if (!prov) {
            throw new Error('No EIP-1193 provider available to request accounts.');
        }
        const accounts = await prov.request({ method: 'eth_requestAccounts' });
        if (Array.isArray(accounts) && typeof accounts[0] === 'string') {
            return toSdkAddress(accounts[0]);
        }
        throw new Error('Wallet did not return accounts from eth_requestAccounts');
    }
    async readContract(args) {
        // Optional safety: verify configured chainId matches RPC chainId.
        const rpcChainId = await this.publicClient.getChainId();
        if (rpcChainId !== this.chainId) {
            throw new Error(`RPC chainId mismatch: SDK configured for chainId=${this.chainId} but rpcUrl reports chainId=${rpcChainId}`);
        }
        return (await this.publicClient.readContract({
            address: toViemAddress(args.address),
            abi: args.abi,
            functionName: args.functionName,
            args: (args.args ?? []),
        }));
    }
    async writeContract(args) {
        if (!this.walletClient) {
            throw new Error('No signer available. Configure walletProvider (browser) or privateKey (server).');
        }
        // Ensure account exists / is connected
        // IMPORTANT:
        // - If we have a local private key account, pass the ACCOUNT OBJECT so viem signs locally and uses eth_sendRawTransaction.
        // - If we're on a browser wallet, pass the address so the wallet signs and uses eth_sendTransaction (via the wallet provider).
        const accountForViem = (this.account ?? (await this.ensureAddress()));
        // Browser safety: if wallet is on the wrong chain, fail with a clear message.
        try {
            const walletChainId = await this.walletClient.getChainId?.();
            if (typeof walletChainId === 'number' && walletChainId !== this.chainId) {
                throw new Error(`Wallet chainId mismatch: expected chainId=${this.chainId}, got chainId=${walletChainId}. ` +
                    `Please switch the wallet network.`);
            }
        }
        catch {
            // If not supported, we rely on RPC errors or downstream handling.
        }
        const hash = (await this.walletClient.writeContract({
            address: toViemAddress(args.address),
            abi: args.abi,
            functionName: args.functionName,
            args: (args.args ?? []),
            account: accountForViem,
            ...toViemTxOptions(args.options),
        }));
        return hash;
    }
    async sendTransaction(args) {
        if (!this.walletClient) {
            throw new Error('No signer available. Configure walletProvider (browser) or privateKey (server).');
        }
        const accountForViem = (this.account ?? (await this.ensureAddress()));
        const hash = (await this.walletClient.sendTransaction({
            to: toViemAddress(args.to),
            data: args.data,
            account: accountForViem,
            ...toViemTxOptions(args.options),
        }));
        return hash;
    }
    async waitForTransaction(args) {
        let receipt;
        try {
            receipt = await this.publicClient.waitForTransactionReceipt({
                hash: args.hash,
                timeout: args.timeoutMs,
                confirmations: args.confirmations,
            });
        }
        catch (err) {
            const message = err instanceof Error ? err.message : String(err);
            if (this.receiptClient && message.toLowerCase().includes('timed out')) {
                receipt = await this.receiptClient.waitForTransactionReceipt({
                    hash: args.hash,
                    timeout: args.timeoutMs,
                    confirmations: args.confirmations,
                });
            }
            else {
                throw err;
            }
        }
        const logs = (receipt.logs || []).map((l) => ({
            address: toSdkAddress(l.address),
            data: l.data,
            topics: (l.topics || []),
            blockNumber: l.blockNumber,
            transactionHash: l.transactionHash,
            logIndex: typeof l.logIndex === 'number' ? l.logIndex : undefined,
        }));
        const status = receipt.status === 'reverted' ? 'reverted' : 'success';
        return {
            transactionHash: receipt.transactionHash,
            blockNumber: receipt.blockNumber,
            status,
            logs,
        };
    }
    async getEventLogs(args) {
        const event = getAbiItem({ abi: args.abi, name: args.eventName, type: 'event' });
        const logs = await this.publicClient.getLogs({
            address: toViemAddress(args.address),
            event: event,
            args: (args.eventArgs ?? undefined),
            fromBlock: args.fromBlock,
            toBlock: args.toBlock,
        });
        return (logs || []).map((l) => ({
            address: toSdkAddress(l.address),
            data: l.data,
            topics: (l.topics || []),
            blockNumber: l.blockNumber,
            transactionHash: l.transactionHash,
            logIndex: typeof l.logIndex === 'number' ? l.logIndex : undefined,
        }));
    }
    async getBlockNumber() {
        return await this.publicClient.getBlockNumber();
    }
    async getBlockTimestamp(blockTag = 'latest') {
        const block = await this.publicClient.getBlock({ blockTag });
        return block.timestamp;
    }
    keccak256Utf8(message) {
        return keccak256(toBytes(message));
    }
    isAddress(address) {
        return viemIsAddress(address);
    }
    toChecksumAddress(address) {
        return toSdkAddress(viemGetAddress(address));
    }
    async signMessage(message) {
        if (!this.walletClient) {
            throw new Error('No signer available. Configure walletProvider (browser) or privateKey (server).');
        }
        const account = (this.account?.address ?? (await this.ensureAddress()));
        const sig = (await this.walletClient.signMessage({
            account,
            message: typeof message === 'string' ? message : { raw: message },
        }));
        return normalizeEcdsaSignature(sig);
    }
    async signTypedData(args) {
        if (!this.walletClient) {
            throw new Error('No signer available. Configure walletProvider (browser) or privateKey (server).');
        }
        const account = (this.account?.address ?? (await this.ensureAddress()));
        const sig = (await this.walletClient.signTypedData({
            account,
            domain: args.domain,
            types: args.types,
            primaryType: args.primaryType,
            message: args.message,
        }));
        return normalizeEcdsaSignature(sig);
    }
    /**
     * Helper for encoding function data, used for overloaded functions when needed.
     */
    encodeFunctionData(args) {
        return encodeFunctionData({
            abi: args.abi,
            functionName: args.functionName,
            args: (args.args ?? []),
        });
    }
}
//# sourceMappingURL=viem-chain-client.js.map