import { TIMEOUTS } from '../utils/constants.js';
/**
 * Thin client for the external semantic-search endpoint.
 *
 * NOTE: Per requirement, we do not use semantic backend filtering; only `query`, `minScore`, `topK`.
 *
 * SDK defaults (applied here so developers don't need to pass them):
 * - minScore: 0.5
 * - topK: 5000
 */
export class SemanticSearchClient {
    constructor(baseUrl = 'https://semantic-search.ag0.xyz') {
        this.baseUrl = baseUrl;
    }
    async search(query, opts = {}) {
        if (!query || !query.trim())
            return [];
        const minScore = opts.minScore ?? 0.5;
        const limit = opts.topK ?? 5000;
        // API expects "limit" not "topK" (semantic-search.ag0.xyz v1)
        const body = { query: query.trim(), minScore, limit };
        const res = await fetch(`${this.baseUrl}/api/v1/search`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
            signal: AbortSignal.timeout(TIMEOUTS.SEMANTIC_SEARCH),
        });
        if (!res.ok) {
            throw new Error(`Semantic search failed: HTTP ${res.status}`);
        }
        const json = await res.json();
        const raw = Array.isArray(json?.results) ? json.results : Array.isArray(json) ? json : [];
        const results = raw.filter((r) => r != null && typeof r === 'object');
        return results
            .map((r) => ({
            chainId: Number(r.chainId),
            agentId: String(r.agentId),
            score: Number(r.score),
        }))
            .filter((r) => Number.isFinite(r.chainId) && r.agentId.includes(':') && Number.isFinite(r.score));
    }
}
//# sourceMappingURL=semantic-search-client.js.map